var documenterSearchIndex = {"docs":
[{"location":"compare/#Comparison-with-[AdvancedHMC.jl](https://github.com/TuringLang/AdvancedHMC.jl)","page":"Comparison","title":"Comparison with AdvancedHMC.jl","text":"","category":"section"},{"location":"compare/#Comparison-1","page":"Comparison","title":"Comparison 1","text":"","category":"section"},{"location":"compare/","page":"Comparison","title":"Comparison","text":"This example compares the mean of samples generated using Gibbs and AdvancedMH sampling methods. Only one group of parameter is considered with one parameter in this group. The proposal distribution of parameter is chosen as MvNormal(zeros(2),1.0) and sampled uisng MH sampler to sample independently.","category":"page"},{"location":"compare/","page":"Comparison","title":"Comparison","text":"#use packages\nusing GibbsSampler, Distributions\nusing AdvancedMH, MCMCChains\n\n#define MCMC samplers\n\nalg = [MH(), adHMC()]\n\n#define variable groups and sampling methods\nsample_alg = Dict(\n\t:n_grp => 1,\n\t1 => Dict(\n\t\t:type => :ind,\n\t\t:n_vars => 1,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(2),1.0),\n\t\t\t:n_eles => 2,\n\t\t\t:alg => 1\n\t\t)\n\t)\n)\nprior = [MvNormal([2.0,3.0],1.0)]\nlogJoint(params) = sum(logpdf.(prior, params))\n#sample using gibbs sampler\nchn = gibbs(alg, sample_alg, logJoint, itr = 10000, chain_type = :mcmcchain)\n\n\nproposalmh = [MvNormal(zeros(2),1.0)]\nmodel = DensityModel(logJoint)\nspl = RWMH(proposalmh)\nchain = sample(model, spl, 10000; chain_type=Vector{NamedTuple})\n\n#show nmean of each elements\np1 = [chain[i][:param_1][1] for i in 1:length(chain)]\n@show mean(p1) mean(chn[\"param[1][1]\"])","category":"page"},{"location":"compare/","page":"Comparison","title":"Comparison","text":"mean(p1) = 2.0386819762387196\nmean(chn[\"param[1][1]\"]) = 1.9957525645926026\n1.9957525645926026\n","category":"page"},{"location":"compare/","page":"Comparison","title":"Comparison","text":"p2 = [chain[i][:param_1][2] for i in 1:length(chain)]\n@show mean(p2) mean(chn[\"param[1][2]\"])","category":"page"},{"location":"compare/","page":"Comparison","title":"Comparison","text":"mean(p2) = 3.003012417905884\nmean(chn[\"param[1][2]\"]) = 3.0387702707202373\n3.0387702707202373","category":"page"},{"location":"compare/#Comparison-2","page":"Comparison","title":"Comparison 2","text":"","category":"section"},{"location":"compare/","page":"Comparison","title":"Comparison","text":"This example compares the mean of samples generated using Gibbs and AdvancedMH sampling methods. Only one group of parameter is considered with two parameters. The proposal distribution of parameters are chosen as MvNormal(zeros(2),1.0), Normal(0.0,1.0) respectively and sampled uisng MH sampler and sampled independently.","category":"page"},{"location":"compare/","page":"Comparison","title":"Comparison","text":"sample_alg = Dict(\n\t:n_grp => 1,\n\t1 => Dict(\n\t\t:type => :ind,\n\t\t:n_vars => 2,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(2),1.0),\n\t\t\t:n_eles => 2,\n\t\t\t:alg => 1\n\t\t),\n\t\t2 => Dict(\n\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t:n_eles => 1,\n\t\t\t:alg => 1\n\t\t)\n\t)\n)\nprior = [MvNormal([2.0,3.0],1.0), Normal(4.0, 1.0)]\nlogJoint(params) = sum(logpdf.(prior, params))\n#sample using gibbs sampler\nchn = gibbs(alg, sample_alg, logJoint, itr = 10000, chain_type = :mcmcchain)\n\nproposalmh = [MvNormal(zeros(2),1.0), Normal(0.0,1.0)]\nmodel = DensityModel(logJoint)\nspl = RWMH(proposalmh)\nchain = sample(model, spl, 10000; chain_type=Vector{NamedTuple})\np1 = [chain[i][:param_1][1] for i in 1:length(chain)]\n@show mean(p1) mean(chn[\"param[1][1]\"])\n\np2 = [chain[i][:param_1][2] for i in 1:length(chain)]\n@show mean(p2) mean(chn[\"param[1][2]\"])\n\np3 = [chain[i][:param_2] for i in 1:length(chain)]\n@show mean(p3) mean(chn[\"param[2][1]\"])","category":"page"},{"location":"compare/#Comparison-3","page":"Comparison","title":"Comparison 3","text":"","category":"section"},{"location":"compare/","page":"Comparison","title":"Comparison","text":"This example compares the mean of samples generated using Gibbs and AdvancedMH sampling methods. Only one group of parameter is considered with two parameters. The proposal distribution of parameters are chosen as MvNormal(zeros(2),1.0), Normal(0.0,1.0) respectively and sampled uisng MH sampler and sampled together.","category":"page"},{"location":"compare/","page":"Comparison","title":"Comparison","text":"\nsample_alg = Dict(\n\t:n_grp => 1,\n\t1 => Dict(\n\t\t:type => :dep,\n\t\t:n_vars => 2,\n\t\t:alg => 2,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(2),1.0),\n\t\t\t:n_eles => 2\n\t\t),\n\t\t2 => Dict(\n\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t:n_eles => 1\n\t\t)\n\t)\n)\nprior = [MvNormal([2.0,3.0],1.0), Normal(4.0, 1.0)]\nlogJoint(params) = sum(logpdf.(prior, params))\n#sample using gibbs sampler\nchn = gibbs(alg, sample_alg, logJoint, itr = 10000, chain_type = :mcmcchain)\n\nproposalmh = [MvNormal(zeros(2),1.0), Normal(0.0,1.0)]\nmodel = DensityModel(logJoint)\nspl = RWMH(proposalmh)\nchain = sample(model, spl, 10000; chain_type=Vector{NamedTuple})\n\np1 = [chain[i][:param_1][1] for i in 1:length(chain)]\n@show mean(p1) mean(chn[\"param[1][1]\"])\n\np2 = [chain[i][:param_1][2] for i in 1:length(chain)]\n@show mean(p2) mean(chn[\"param[1][2]\"])\n\np3 = [chain[i][:param_2] for i in 1:length(chain)]\n@show mean(p3) mean(chn[\"param[2][1]\"])","category":"page"},{"location":"compare/#Comparison-4","page":"Comparison","title":"Comparison 4","text":"","category":"section"},{"location":"compare/","page":"Comparison","title":"Comparison","text":"This example compares the mean of samples generated using Gibbs and AdvancedMH sampling methods. Only two groups is considered with one parameter in each group. The proposal distribution of parameters are chosen as MvNormal(zeros(2),1.0), MvNormal(zeros(3),1.0) respectively and sampled uisng MH sampler and sampled together.","category":"page"},{"location":"compare/","page":"Comparison","title":"Comparison","text":"sample_alg = Dict(\n\t:n_grp => 2,\n\t1 => Dict(\n\t\t:type => :ind,\n\t\t:n_vars => 1,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(2),1.0),\n\t\t\t:n_eles => 2,\n\t\t\t:alg => 1\n\t\t)\n\t),\n\t2 => Dict(\n\t\t:type => :ind,\n\t\t:n_vars => 1,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(3),1.0),\n\t\t\t:n_eles => 3,\n\t\t\t:alg => 1\n\t\t)\n\t)\n)\nprior = [MvNormal([2.0,3.0],1.0), MvNormal([4.0,3.0, 5.0],1.0)]\nlogJoint(params) = sum(logpdf.(prior, params))\n#sample using gibbs sampler\nchn = gibbs(alg, sample_alg, logJoint, itr = 10000, chain_type = :mcmcchain)\n\nproposalmh = [MvNormal(zeros(2),1.0), MvNormal(zeros(3),1.0)]\nmodel = DensityModel(logJoint)\nspl = RWMH(proposalmh)\nchain = sample(model, spl, 10000; chain_type=Vector{NamedTuple})\n\np1 = [chain[i][:param_1][1] for i in 1:length(chain)]\n@show mean(p1) mean(chn[\"param[1][1]\"])\n\np2 = [chain[i][:param_1][2] for i in 1:length(chain)]\n@show mean(p2) mean(chn[\"param[1][2]\"])\n\np3 = [chain[i][:param_2][1] for i in 1:length(chain)]\n@show mean(p3) mean(chn[\"param[2][1]\"])\n\np4 = [chain[i][:param_2][2] for i in 1:length(chain)]\n@show mean(p4) mean(chn[\"param[2][2]\"])\n\np5 = [chain[i][:param_2][3] for i in 1:length(chain)]\n@show mean(p5) mean(chn[\"param[2][3]\"])","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section contains different examples that describes the usage of GibbsSampler.jl package.","category":"page"},{"location":"examples/#Different-MCMC-Samplers-for-parameter-sampling","page":"Examples","title":"Different MCMC Samplers for parameter sampling","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The GibbsSampler.jl allows the use of MH, HMC, NUTS MCMC samplers with the help of AdvancedMH.jl and AdvancedHMC.jl package. The GibbsSampler.gibbs(...) function has an input corresponds to alg, which decides the MCMC sampler availble based on structs defined by the package (Eg: MH(), adHMC(), adNUTS() etc.). This algorithm need to to be mapped to parameter groups using another dictionary input sample_alg. The key of sample_alg represents the parameter group and the value vector contains the index of the sampling algorithm defined in alg with proposal distribution.","category":"page"},{"location":"examples/#Use-of-AdvancedMH-as-MCMC-sampler","page":"Examples","title":"Use of AdvancedMH as MCMC sampler","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The MH() struct defined with GibbsSampler.jl package is used to select MCMC sampler for each parameter in Gibbs sampling. ","category":"page"},{"location":"examples/#Example-1","page":"Examples","title":"Example 1","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we defined variable sample_alg with a group with two sub groups. One of the subgroup sampled together with HMC sampler and other subgroup variables sampled in parallel using MH sampler.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"#use packages\nusing GibbsSampler\nusing Distributions\n\n#define MCMC samplers\nalg = [MH(), adHMC()]\n\n#define sample_alg parameter\nsample_alg = Dict(\n\t:n_grp => 2,\n\t1 => Dict(\n\t\t:type => :ind,\n\t\t:n_vars => 2,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(2),1.0),\n\t\t\t:n_eles => 2,\n\t\t\t:alg => 1\n\t\t),\n\t\t2 => Dict(\n\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t:n_eles => 1,\n\t\t\t:alg => 1\n\t\t)\n\t),\n\t2 => Dict(\n\t\t:type => :dep,\n\t\t:n_vars => 2,\n\t\t:alg => 2,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(3),1.0),\n\t\t\t:n_eles => 3\n\t\t),\n\t\t2 => Dict(\n\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t:n_eles => 1\n\t\t)\n\t)\n)\n#define prior distribution\nprior = [MvNormal([1.0,2.0],1.0),Normal(2.0,1.0), MvNormal([2.0,4.0,3.0],1.0),Normal(-1.0,1.0)]\n\n#define logjoint function\nlogJoint(params) = sum(logpdf.(prior, params))\n\n#sample\nchn = gibbs(alg, sample_alg, logJoint, itr = 10000, chain_type = :mcmcchain)","category":"page"},{"location":"examples/#Example-2","page":"Examples","title":"Example 2","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we defined variable sample_alg with a group with two sub groups. One of the subgroup sampled together and other subgroup variables sampled in parallel.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"alg = [MH(), adHMC()]\nsample_alg = Dict(\n\t:n_grp => 1,\n\t#grp\n\t1 => Dict(\t\t\n\t\t:type => :ind,\n\t\t:n_sub_grp => 2,\t\t\n\t\t#sub grp\n\t\t1 => Dict(\t\t\t\n\t\t\t:type => :ind,\n\t\t\t:n_vars => 2,\n\t\t\t#params\n\t\t\t1 => Dict(\n\t\t\t\t:proposal => MvNormal(zeros(2),1.0),\n\t\t\t\t:n_eles => 2,\n\t\t\t\t:alg => 1\n\t\t\t),\n\t\t\t#params\n\t\t\t2 => Dict(\n\t\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t\t:n_eles => 1,\n\t\t\t\t:alg => 1\n\t\t\t)\n\t\t),\n\t\t#sub grp\n\t\t2 => Dict(\t\t\t\n\t\t\t:type => :dep,\n\t\t\t:n_vars => 2,\n\t\t\t:alg => 1,\n\t\t\t#params\n\t\t\t1 => Dict(\n\t\t\t\t:proposal => MvNormal(zeros(2),1.0),\n\t\t\t\t:n_eles => 2,\t\t\t\n\t\t\t),\n\t\t\t#params\n\t\t\t2 => Dict(\n\t\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t\t:n_eles => 1\n\t\t\t)\n\t\t)\n\t)\n)\n\nprior = [MvNormal([2.0, 3.0],1.0), Normal(2.0,1.0), MvNormal([4.0,5.0],1.0), Normal(1.0,1.0)]\nlogJoint(params) = sum(logpdf.(prior, params))\n#sample using gibbs sampler\nchn = gibbs(alg, sample_alg, logJoint, itr = 10000, chain_type = :mcmcchain)","category":"page"},{"location":"examples/#Example-3","page":"Examples","title":"Example 3","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we defined variable sample_alg with a group with two sub groups. Variables in both sub groups sampled together.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sample_alg = Dict(\n\t:n_grp => 1,\n\t1 => Dict(\t\t\n\t\t:type => :dep,\n\t\t:n_sub_grp => 2,\n\t\t:alg => 1,\t\t\n\t\t#sub grp\n\t\t1 => Dict(\t\t\t\n\t\t\t:n_vars => 2,\n\t\t\t#params\n\t\t\t1 => Dict(\n\t\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t\t:n_eles => 1\t\t\t\n\t\t\t),\n\t\t\t#params\n\t\t\t2 => Dict(\n\t\t\t\t:proposal => MvNormal(zeros(3),1.0),\n\t\t\t\t:n_eles => 3,\n\t\t\t)\n\t\t),\n\t\t#sub grp\n\t\t2 => Dict(\t\t\t\n\t\t\t:n_vars => 2,\n\t\t\t#params\n\t\t\t1 => Dict(\n\t\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t\t:n_eles => 1,\t\t\t\t\n\t\t\t),\n\t\t\t#params\n\t\t\t2 => Dict(\n\t\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t\t:n_eles => 1,\n\t\t\t)\n\t\t)\n\t)\n)\n\nprior = [Normal(3.0,1.0), MvNormal([1.0,2.0,3.0],1.0),Normal(5.0,1.0), Normal(2.0,1.0)]\nlogJoint(params) = sum(logpdf.(prior, params))\n#sample using gibbs sampler\nchn = gibbs(alg, sample_alg, logJoint, itr = 10000, chain_type = :mcmcchain)\n","category":"page"},{"location":"examples/#Example-4","page":"Examples","title":"Example 4","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we defined variable sample_alg with 3 groups with details as follwos:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Group 1: 2 Subgroups, sampled in parallel","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"- Subgroup 1: Two variables, sampled in parallel\n- Subgroup 2: Two variables, sampled together","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Group 2: 2 Subgroups, sampled together\nGroup 3; No subgroups, only two variables, sampled together","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sample_alg = Dict(\n\t:n_grp => 3,\n\t#grp\n\t1 => Dict(\t\t\n\t\t:type => :ind,\n\t\t:n_sub_grp => 2,\t\t\n\t\t#sub grp\n\t\t1 => Dict(\t\t\t\n\t\t\t:type => :ind,\n\t\t\t:n_vars => 2,\n\t\t\t#params\n\t\t\t1 => Dict(\n\t\t\t\t:proposal => MvNormal(zeros(2),1.0),\n\t\t\t\t:n_eles => 2,\n\t\t\t\t:alg => 1\n\t\t\t),\n\t\t\t#params\n\t\t\t2 => Dict(\n\t\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t\t:n_eles => 1,\n\t\t\t\t:alg => 1\n\t\t\t)\n\t\t),\n\t\t#sub grp\n\t\t2 => Dict(\t\t\t\n\t\t\t:type => :dep,\n\t\t\t:n_vars => 2,\n\t\t\t:alg => 1,\n\t\t\t#params\n\t\t\t1 => Dict(\n\t\t\t\t:proposal => MvNormal(zeros(2),1.0),\n\t\t\t\t:n_eles => 2,\t\t\t\n\t\t\t),\n\t\t\t#params\n\t\t\t2 => Dict(\n\t\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t\t:n_eles => 1\n\t\t\t)\n\t\t)\n\t),\n\t2 => Dict(\t\t\n\t\t:type => :dep,\n\t\t:n_sub_grp => 2,\n\t\t:alg => 1,\t\t\n\t\t#sub grp\n\t\t1 => Dict(\t\t\t\n\t\t\t:n_vars => 2,\n\t\t\t#params\n\t\t\t1 => Dict(\n\t\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t\t:n_eles => 1\t\t\t\n\t\t\t),\n\t\t\t#params\n\t\t\t2 => Dict(\n\t\t\t\t:proposal => MvNormal(zeros(3),1.0),\n\t\t\t\t:n_eles => 3,\n\t\t\t)\n\t\t),\n\t\t#sub grp\n\t\t2 => Dict(\t\t\t\n\t\t\t:n_vars => 2,\n\t\t\t#params\n\t\t\t1 => Dict(\n\t\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t\t:n_eles => 1,\t\t\t\t\n\t\t\t),\n\t\t\t#params\n\t\t\t2 => Dict(\n\t\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t\t:n_eles => 1,\n\t\t\t)\n\t\t)\n\t),\n\t3 => Dict(\n\t\t:type => :dep,\n\t\t:n_vars => 2,\n\t\t:alg => 1,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(3),1.0),\n\t\t\t:n_eles => 3\n\t\t),\n\t\t2 => Dict(\n\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t:n_eles => 1\n\t\t)\n\t)\n)\nprior = [\n\tMvNormal([1.0,2.0],1.0), Normal(3.0,1.0), MvNormal([4.0,5.0],1.0), Normal(4.0,1.0), \n\tNormal(3.0,1.0), MvNormal([2.0,1.0,5.0],1.0), Normal(4.0,1.0), Normal(3.0,1.0), \n\tMvNormal([4.0,2.0,1.0],1.0), Normal(3.0,1.0)\n]\n\nlogJoint(params) = sum(logpdf.(prior, params))\n#sample using gibbs sampler\nchn = gibbs(alg, sample_alg, logJoint, itr = 10000, chain_type = :mcmcchain)","category":"page"},{"location":"examples/#Example-5","page":"Examples","title":"Example 5","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we defined variable sample_alg with a group with two sub groups. One of the subgroup sampled together with NUTS sampler and other subgroup variables sampled in parallel using MH sampler.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"#use packages\nusing GibbsSampler\nusing Distributions\n\n#define MCMC samplers\nalg = [MH(), adHMC(), adNUTS()]\n\n#define sample_alg parameter\nsample_alg = Dict(\n\t:n_grp => 2,\n\t1 => Dict(\n\t\t:type => :ind,\n\t\t:n_vars => 2,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(2),1.0),\n\t\t\t:n_eles => 2,\n\t\t\t:alg => 1\n\t\t),\n\t\t2 => Dict(\n\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t:n_eles => 1,\n\t\t\t:alg => 1\n\t\t)\n\t),\n\t2 => Dict(\n\t\t:type => :dep,\n\t\t:n_vars => 2,\n\t\t:alg => 3,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(3),1.0),\n\t\t\t:n_eles => 3\n\t\t),\n\t\t2 => Dict(\n\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t:n_eles => 1\n\t\t)\n\t)\n)\n#define prior distribution\nprior = [MvNormal([1.0,2.0],1.0),Normal(2.0,1.0), MvNormal([2.0,4.0,3.0],1.0),Normal(-1.0,1.0)]\n\n#define logjoint function\nlogJoint(params) = sum(logpdf.(prior, params))\n\n#sample\nchn = gibbs(alg, sample_alg, logJoint, itr = 10000, chain_type = :mcmcchain)","category":"page"},{"location":"examples/#Example-6","page":"Examples","title":"Example 6","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we defined variable sample_alg with a group with two sub groups. One of the subgroup sampled together with NUTS sampler with reverse differentiation backend.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"#use packages\nusing GibbsSampler\nusing Distributions\nusing ReverseDiff\n\n#define MCMC samplers\nalg = [MH(), adHMC(), adNUTS(backend = ReverseDiff)]\n\n#define sample_alg parameter\nsample_alg = Dict(\n\t:n_grp => 1,\n\t1 => Dict(\n\t\t:type => :dep,\n\t\t:n_vars => 2,\n\t\t:alg => 3,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(3),1.0),\n\t\t\t:n_eles => 3\n\t\t),\n\t\t2 => Dict(\n\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t:n_eles => 1\n\t\t)\n\t)\n)\n#define prior distribution\nprior = [MvNormal([2.0,4.0,3.0],1.0),Normal(-1.0,1.0)]\n\n#define logjoint function\nfunction  logJoint(params)\n\t@show typeof(params[2]) size(params[2])\n\tlpdf = identity.(logpdf.(prior, params))\n\treturn sum(lpdf)\nend\n\n#sample\nchn = gibbs(alg, sample_alg, logJoint, itr = 10000, chain_type = :mcmcchain)","category":"page"},{"location":"examples/#Example-7","page":"Examples","title":"Example 7","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we defined variable sample_alg ....","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"#use packages\nusing GibbsSampler\nusing Distributions\nusing ReverseDiff\n\n#define MCMC samplers\nalg = [MH(), adHMC(), adNUTS(backend = ReverseDiff)]\nsample_alg = Dict(\n\t:n_grp => 1,\n\t1 => Dict(\n\t\t:type => :ind,\n\t\t:n_vars => 2,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(2),1.0),\n\t\t\t:n_eles => 2,\n\t\t\t:alg => 1\n\t\t),\n\t\t2 => Dict(\n\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t:n_eles => 1,\n\t\t\t:alg => 1\n\t\t)\n\t)\n)\n\n#define prior distribution\nprior = [MvNormal([2.0,3.0],1.0),Normal(-1.0,1.0)]\n\n#define logjoint function\nfunction logJoint(params)\n\tsumval = 0.0\n\tfor jk in 1:length(params)\n\t\tsumval +=logpdf(prior[jk], params[jk])\n\tend\n\treturn sumval\nend\n\n#sample\nchn = gibbs(alg, sample_alg, logJoint, itr = 200, chain_type = :mcmcchain)","category":"page"},{"location":"structs/#GibbsSampler.jl","page":"Sampling Algorithm","title":"GibbsSampler.jl","text":"","category":"section"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"CurrentModule = GibbsSampler\nDocTestSetup = quote\n    using GibbsSampler\nend","category":"page"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"There are different MCMC sampling algorithm is available with GibbsSampler.jl package.","category":"page"},{"location":"structs/#MH-Sampler","page":"Sampling Algorithm","title":"MH Sampler","text":"","category":"section"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"The MH sampler can be configured as struct like below:","category":"page"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"MH","category":"page"},{"location":"structs/#GibbsSampler.MH","page":"Sampling Algorithm","title":"GibbsSampler.MH","text":"MH\n\nMH is a struct to choose MH MCMC sampling algorithm\n\nFields\n\nn_samples\t: Number of iterations. Default value is 10\n\nExample\n\na = MH(n_samples = 4)\n\n\n\n\n\n","category":"type"},{"location":"structs/#adHMC-Sampler","page":"Sampling Algorithm","title":"adHMC Sampler","text":"","category":"section"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"The HMC sampler can be configured as struct like below:","category":"page"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"adHMC","category":"page"},{"location":"structs/#GibbsSampler.adHMC","page":"Sampling Algorithm","title":"GibbsSampler.adHMC","text":"adHMC\n\nadHMC is a struct to choose HMC MCMC sampling algorithm\n\nFields\n\nn_samples\t: Number of iterations\nn_adapts\t: Adaptation\nbackend \t: Automatic differentiation backend\n\nExample\n\na = adHMC( nsamples = 10, nadapts = 5, backend = ForwardDiff )\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"The backend variable is used to select the automatic differentiation backend. ForwardDiff and ReversedDiff are the values to select forward and reverse differentiation, respectively.","category":"page"},{"location":"structs/#adNUTS-Sampler","page":"Sampling Algorithm","title":"adNUTS Sampler","text":"","category":"section"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"The NUTS sampler can be configured as struct like below:","category":"page"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"adNUTS","category":"page"},{"location":"structs/#GibbsSampler.adNUTS","page":"Sampling Algorithm","title":"GibbsSampler.adNUTS","text":"adNUTS\n\nadNUTS is a struct to choose NUTS MCMC sampling algorithm\n\nFields\n\nn_samples\t: Number of iterations\nn_adapts\t: Adaptation\nbackend \t: Automatic differentiation backend\n\nExample\n\na = adNUTS( nsamples = 10, nadapts = 5, backend = ForwardDiff )\n\n\n\n\n\n","category":"type"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"The backend variable is used to select the automatic differentiation backend. ForwardDiff and ReversedDiff are the values to select forward and reverse differentiation, respectively.","category":"page"},{"location":"#GibbsSampler.jl","page":"Home","title":"GibbsSampler.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GibbsSampler\nDocTestSetup = quote\n    using GibbsSampler\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package helps to generate posterior samples using Gibbs sampling algorithm from a specified multivariate probability distribution when direct sampling is difficult. This Julia package supports MH and HMC based algorithms with different automatic differentiation backends.","category":"page"},{"location":"#Gibbs-Sampling","page":"Home","title":"Gibbs Sampling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"gibbs(alg, sample_alg, logJoint::Function;  \n\t\trevt = [reverse_transform for _ in 1:find_var_count(sample_alg)],\n\t\titr = 100, burn_in = Int(round(itr*sample_alg[:n_grp]*0.2)),\n\t\tchain_type=:default, progress = true\n\t) where {T <: Distribution}\n","category":"page"},{"location":"#GibbsSampler.gibbs-Union{Tuple{T}, Tuple{Any,Any,Function}} where T<:Distributions.Distribution","page":"Home","title":"GibbsSampler.gibbs","text":"gibbs(alg, sample_alg, logJoint::Function;  \n\trevt = [reverse_transform for _ in 1:find_var_count(sample_alg)],\n\titr = 100, burn_in = Int(round(itr*sample_alg[:n_grp]*0.2)),\n\tparam_names = default_param_name(find_var_count(sample_alg)),\n\tchain_type=:default, progress = true\n) where {T <: Distribution}\n\nTo generate posterior samples using Gibbs sampling algorithm\n\nInputs\n\nalg \t\t\t:MCMC algorithms based on structs defined in this package as vector eg: alg = [MH()]\nsample_alg \t\t:A dictionary maps alg to parameter groups index and it contains proposal distribution\n\nif required by the sampling algorithm. \n\nEg: sample_alg = Dict( \t:n_grp => 1, \t1 => Dict( \t\t:type => :ind, \t\t:n_vars => 1, \t\t1 => Dict( \t\t\t:proposal => MvNormal(zeros(2),1.0), \t\t\t:n_eles => 2, \t\t\t:alg => 1 \t\t) \t) )\n\nHere key is the paramter group and first index in the value (Vector) maps to alg index. Second index in the sample_alg is the proposal distribution. This not mandatory.\n\nlogJoint \t\t:Log PDF as a function\n\nKeyword Arguments\n\nitr \t\t\t:Number of iterations\nburn_in \t\t:Burn in from samples\nchain_type\t\t:Sample chain type. default value is :default. Samples chains formated using MCMCChain.jl\n\nby choosing chain_type as :mcmcchain\n\nprogress \t\t:To show the sampling progress. Default value is true.\nparam_names \t\t:To specify parameter names\n\nOutput\n\nchn\t\t\t:Generated samples\n\n\n\n\n\n","category":"method"},{"location":"#sample_alg-parameter-configuration","page":"Home","title":"sample_alg parameter configuration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"sample_alg contains the information regarding parameter groups, mapping MCMC sampling algorithms defined in alg parameter for each group, independent and dependent sampling. The sample_alg should be defined as a dictionary with certain keys and values. One example is shown below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"alg = [MH(), adHMC()]\n\nsample_alg = Dict(\n\t:n_grp => 2,\n\t1 => Dict(\n\t\t:type => :ind,\n\t\t:n_vars => 2,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(2),1.0),\n\t\t\t:n_eles => 2,\n\t\t\t:alg => 1\n\t\t),\n\t\t2 => Dict(\n\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t:n_eles => 1,\n\t\t\t:alg => 1\n\t\t)\n\t),\n\t2 => Dict(\n\t\t:type => :dep,\n\t\t:n_vars => 2,\n\t\t:alg => 2,\n\t\t1 => Dict(\n\t\t\t:proposal => MvNormal(zeros(3),1.0),\n\t\t\t:n_eles => 3\n\t\t),\n\t\t2 => Dict(\n\t\t\t:proposal => Normal(0.0,1.0),\n\t\t\t:n_eles => 1\n\t\t)\n\t)\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":":n_grp key defines the number of parameter groups, and in this example, two groups exist. Then each group is defined keys with continuous numbers, here 1 and 2.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each group information is again stored in a dictionary, and it also contains many keys. Then each parameter is defined keys with continuous numbers, here 1 and 2.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The key :type is to select parallel sampling of parameters or for group sampling, and it has two options :ind and :dep. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"- The value `:ind` chooses parallel sampling of group parameters. Each parameter in this group is sampled independently by selecting previous values. Then all group parameters will be joined together to form the next sample. \n- If `:type` is `:dep`, those group parameter sampled together to generate the next sample.","category":"page"},{"location":"","page":"Home","title":"Home","text":"n_vars defines the number of parameters in each group. \n:alg contains the index of the MCMC sampling algorithm defined in the alg parameter. If :type value is :ind then, it is possible to sample each parameter using different samplers. So, it is not required to define :alg key in :ind groups.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each parameter information is again stored in a dictionary, and it also contains many keys. ","category":"page"},{"location":"","page":"Home","title":"Home","text":":proposal : Proposal distribution of that parameter. It is mandatory for MH based sampling; however, it is not required for adHMC or adNUTS based sampling.\n:n_eles: Number of elements in each parameter.\n:alg: If group :type is :ind, then we have to define MCMC sampling algorithm with each parameter with :alg key.","category":"page"}]
}
