var documenterSearchIndex = {"docs":
[{"location":"structs/#GibbsSampler.jl","page":"Sampling Algorithm","title":"GibbsSampler.jl","text":"","category":"section"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"CurrentModule = GibbsSampler\nDocTestSetup = quote\n    using GibbsSampler\nend","category":"page"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"There are different MCMC sampling algorithm is availbale with GibbsSampler.jl package","category":"page"},{"location":"structs/#MH-Sampler","page":"Sampling Algorithm","title":"MH Sampler","text":"","category":"section"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"The MH sampler can be configured as struct like below:","category":"page"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"MH","category":"page"},{"location":"structs/#GibbsSampler.MH","page":"Sampling Algorithm","title":"GibbsSampler.MH","text":"MH\n\nMH is a struct to choose MH MCMC sampling algorithm\n\nFields\n\nn_samples\t: Number of iterations. Default value is 10\n\nExample\n\na = MH(n_samples = 4)\n\n\n\n\n\n","category":"type"},{"location":"structs/#adHMC-Sampler","page":"Sampling Algorithm","title":"adHMC Sampler","text":"","category":"section"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"The HMC sampler can be configured as struct like below:","category":"page"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"adHMC","category":"page"},{"location":"structs/#GibbsSampler.adHMC","page":"Sampling Algorithm","title":"GibbsSampler.adHMC","text":"adHMC\n\nadHMC is a struct to choose HMC MCMC sampling algorithm\n\nFields\n\nn_samples\t: Number of iterations\nn_adapts\t: Adaptation\nbackend \t: Automatic differentiation backend\n\nExample\n\na = adHMC( nsamples = 10, nadapts = 5, backend = ForwardDiff )\n\n\n\n\n\n","category":"type"},{"location":"structs/#adNUTS-Sampler","page":"Sampling Algorithm","title":"adNUTS Sampler","text":"","category":"section"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"The NUTS sampler can be configured as struct like below:","category":"page"},{"location":"structs/","page":"Sampling Algorithm","title":"Sampling Algorithm","text":"adNUTS","category":"page"},{"location":"structs/#GibbsSampler.adNUTS","page":"Sampling Algorithm","title":"GibbsSampler.adNUTS","text":"adNUTS\n\nadNUTS is a struct to choose NUTS MCMC sampling algorithm\n\nFields\n\nn_samples\t: Number of iterations\nn_adapts\t: Adaptation\nbackend \t: Automatic differentiation backend\n\nExample\n\na = adNUTS( nsamples = 10, nadapts = 5, backend = ForwardDiff )\n\n\n\n\n\n","category":"type"},{"location":"#GibbsSampler.jl","page":"Home","title":"GibbsSampler.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GibbsSampler\nDocTestSetup = quote\n    using GibbsSampler\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package helps to generate posterior samples using Gibbs sampling algorithm from a specified multivariate probability distribution when direct sampling is difficult. This Julia package supports MH and HMC based algorithms with different automatic differentiation backends.","category":"page"},{"location":"#Gibbs-Sampling","page":"Home","title":"Gibbs Sampling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"gibbs(proposal::Vector{T}, logJoint::Function; \n\t\tsample_alg = [MH() for _ in 1:length(proposal)], \n\t\titr = 100, burn_in = Int(round(itr*0.2))\n\t) where {T <: Distribution}","category":"page"},{"location":"#GibbsSampler.gibbs-Union{Tuple{T}, Tuple{Array{T,1},Function}} where T<:Distributions.Distribution","page":"Home","title":"GibbsSampler.gibbs","text":"function gibbs(proposal::Vector{T}, logJoint::Function; \n\tsample_alg = [MH() for _ in 1:length(proposal)], \n\trevt = [reverse_transform for _ in 1:length(proposal)],\n\titr = 100, burn_in = Int(round(itr*0.2))\n) where {T <: Distribution}\n\nTo generate posterior samples using Gibbs sampling algorithm\n\nInputs\n\nproposal \t\t:proposal distributions as vector\nlogJoint \t\t:Log PDF as a function\n\nKeyword Arguments\n\nsample_alg \t:MCMC sampling for each parameter\nitr \t\t\t:Number of iterations\nburn_in \t\t:Burn in from samples\n\nOutput\n\nchn \t\t\t:Generated samples\n\n\n\n\n\n","category":"method"}]
}
